# This test shows how to easily transport extra variables using the finite volume solver.  Extra variables are conserved scalars that are transported with the flow.  Examples include zMix and other progresses variables.

---
# metadata for the simulation
environment:
  title: _extraVariableTransport
  tagDirectory: false
arguments: 
  dm_plex_separate_marker: ""
# set up the time stepper responsible for marching in time
timestepper:
  # use io to save results to a file allowing visualization and restart
  io:
    interval: 0
  name: theMainTimeStepper
  # time stepper specific input arguments
  arguments:
    ts_type: rk
    ts_adapt_type: none
    ts_max_steps: 1
  # the domain/mesh must be specified at the start of a simulation
  domain: !ablate::domain::BoxMesh
    name: simpleBoxField
    faces: [ 12, 12 ]
    lower: [ 0, 0 ]
    upper: [ .5, .1 ]
    boundary: [ "NONE", "NONE" ]
    simplex: false

    # specify any modifications to be performed to the mesh/domain
    modifiers:
      # if using mpi, this modifier distributes cells
      - !ablate::domain::modifiers::GhostBoundaryCells
      # if using a FVM ghost boundary cells must be added
      - !ablate::domain::modifiers::DistributeWithGhostCells
    fields:
      # all fields must be defined before solvers.  The ablate::finiteVolume::CompressibleFlowFields is a helper
      # class that creates the required fields for the compressible flow solver (rho, rhoE, rhoU, ...)
      - !ablate::finiteVolume::CompressibleFlowFields
        eos: !ablate::eos::PerfectGas &eos
          parameters:
            gamma: 1.4
            Rgas: 287
        # the CompressibleFlowFields class can take extraVariable arguments.  This defines the conserved and non-conserved field for each component
        extraVariables: ["ev1", "ev2","ev3"]
        species: [ N2, H2O, O2 ]

  initialization:
    # the ablate::finiteVolume::fieldFunctions::Euler helper can define the "euler" field (rho, rhoE, rhoU, rhoV) from more common inputs
    - !ablate::finiteVolume::fieldFunctions::Euler
      &eulerFlowFieldState
      state: &flowFieldState
        eos: *eos
        temperature: "300"
        pressure: "101325.0"
        velocity: "25., 25"
        # individual mass fractions must be passed to the flow field state to compute density, energy, etc.
        massFractions: !ablate::finiteVolume::fieldFunctions::MassFractions
          &massFractions
          eos: *eos
          values:
            - fieldName: N2
              field: "x > .1 ? .2 : 1.0"
            - fieldName: H2O
              field: " x> .1 ? .3 :0"
            - fieldName: O2
              field: " x > .1 ? .5 : 0"
    # the same state can be used to internalize the DensityMassFractions field from density and mass fractions
    - !ablate::finiteVolume::fieldFunctions::DensityMassFractions
      state: *flowFieldState
    # the density*ev field must be specified. The DensityExtraVariables class helps by computing density and each ev value using the specified list functions
    - !ablate::finiteVolume::fieldFunctions::DensityExtraVariables
      &densityEVFlowFieldState
      state: *flowFieldState
      # a list of functions used to describe the extra variable initialization
      functions:
        - .25 # ev1 is set to a constant value of 0.25
        - .1
        - .004
        #- !ablate::mathFunctions::geom::Sphere
         # the sphere methFunction can be used to specify ev2 with a different number inside (1.5) and outside (0, by default)
         # center: [ .25, .25 ]
         # radius: .25
         # insideValues:  1.5 */

# this problem uses a single solver (!ablate::finiteVolume::LesCompressibleFlowSolver)
solver: !ablate::finiteVolume::CompressibleFlowSolver
  id: evExample
  parameters:
    cfl: .5
  # a flux calculator must be specified to so solver for advection
  fluxCalculator: !ablate::finiteVolume::fluxCalculator::AusmpUp
    mInf: .3
  computePhysicsTimeStep: true

  # the default transport object assumes constant values for k, mu, diff
  transport:
    diff: 1E-4
    k: 1E-4
    mu: 1E-4

  # share the existing eos with the compressible flow solver
  eos: *eos

  additionalProcesses:
    # the ArbitrarySource process was added to define a region of additional ev source
    - !ablate::finiteVolume::processes::LES
      tke: ev3
      eos: *eos


     # using constant boundary condition values on all sides with the specified values for euler and densityFlow based upon the previous boundary values
  boundaryConditions:
    - !ablate::finiteVolume::boundaryConditions::EssentialGhost
      boundaryName: "walls"
      labelIds: [1, 2, 3, 4]
      boundaryValue: *eulerFlowFieldState
    - !ablate::finiteVolume::boundaryConditions::EssentialGhost
      boundaryName: "walls"
      labelIds: [ 1, 2, 3, 4 ]
      boundaryValue: *densityEVFlowFieldState
    - !ablate::finiteVolume::boundaryConditions::EssentialGhost
      boundaryName: "walls"
      labelIds: [ 1, 2, 3, 4 ]
      boundaryValue: *massFractions
  monitors:
    # output the time and dt at each time step
    - !ablate::monitors::TimeStepMonitor

    # define a list of probes to record high frequency information
    - !ablate::monitors::Probes
      probes:
        - name: a
          location: [.25, .25]
        - name: b
          location: [.75, .25]
        - name: c
          location: [ .25, .75 ]
      bufferSize: 10
      variables:  [velocity, densityEV, ev, euler ] # these fields will be saved to a text file at the specified locations

    # define a probe using a rake, which uses a start/end location and a number of probes to compute initial probe locations
    - !ablate::monitors::Probes
      probes: !ablate::monitors::probes::Rake
        name: rakeProbe
        start: [.75, .5]
        end: [.25, 0.5]
        number: 3
      bufferSize: 10
      variables: [ velocity, densityEV, ev, euler ]  # these fields will be saved to a text file at the specified locations

        velocity: !ablate::mathFunctions::ParsedSeries
          upperBound: 5000
          lowerBound: 1
          formula: 2 * sqrt(alpha * exp(-2 * ((kappa_o + (3.14/delta - kappa_o) * (i - 1)  / n) / kappa_eta) ^ 2) * (uPrime^2 / kappa_e) * ((kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n)/ kappa_e) ^ 4 / (1* (1 + ((kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n) / kappa_e) )^ (17/6))) * cos( (kappa_o + (3.14/delta - kappa_o) * (i - 1)  / n) * (2/delta)*sin(.5* (kappa_o + (3.14/delta - kappa_o) * (i - 1)  / n)* delta*sin( acos(rand(-1,1))) * cos(rand(0,2*3.14)) )* x + (rand(-3.14/2,3.14/2))),  2 * sqrt(alpha * exp(-2 * ((kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n) / kappa_eta) ^ 2) * (uPrime^2 / kappa_e) * ((kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n)/ kappa_e) ^ 4 / (1* (1 + ((kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n) / kappa_e) )^ (17/6))) * cos( (kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n) * (2/delta)*sin(.5* (kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n)* delta*sin( acos(rand(-1,1))) * sin(rand(0,2*3.14)) )* y + (rand(-3.14/2,3.14/2))),  2 * sqrt(alpha * exp(-2 * ((kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n) / kappa_eta) ^ 2) * (uPrime^2 / kappa_e) * ((kappa_o + (3.14/delta - kappa_o) * (i - 1)  / n)/ kappa_e) ^ 4 / (1* (1 + ((kappa_o + (3.14/delta - kappa_o) * (i - 1)  / n) / kappa_e) )^ (17/6))) * cos( (kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n) * (2/delta)*sin(.5* (kappa_o + (3.14/delta- kappa_o) * (i - 1)  / n)* delta*cos( acos(rand(-1,1))) )* z + (rand(-3.14/2,3.14/2)))
          constants:
            n: 5000
            alpha: 1.453
            delta: 2*3.14*9/100/8
            kappa_eta: 0.8573*5624
            uPrime: 0.25
            kappa_e: 40 * sqrt(5 / 12)
            kappa_o: 100/9
            kappa_max: 3.14/delta
            HI: 1
            LO: -1
            HI1: 2*pi
            LO1: 0
            HI2: pi/2
            LO2: -pi/2
            formula: 2 * sqrt(1.453 * exp(-2 * (((100/9) + (3.14/(2*3.14*9/100/8) - (100/9)) * (i - 1)  / 5000) / 4819) ^ 2) * (.25^2 / 25.82) * (((100/9)+ (3.14/(2*3.14*9/100/8)- (100/9)) * (i - 1)  / 5000)/ 25.82) ^ 4 / (1* (1 + (((100/9) + (3.14/(2*3.14*9/100/8)- (100/9)) * (i - 1)  / 5000) / 25.82) )^ (17/6)))* cos( ((100/9) + (3.14/(2*3.14*9/100/8) - (100/9)) * (i - 1)  / 5000) * (2/(2*3.14*9/100/8))*sin(.5* ((100/9) + (3.14/(2*3.14*9/100/8) - (100/9)) * (i - 1)  / 5000)* (2*3.14*9/100/8)*sin( acos(pRand(-1,1))) * cos(rand(0,2*3.14)) )* x + (rand(-3.14/2,3.14/2))),  2 * sqrt(1.453 * exp(-2 * (((100/9) + (3.14/(2*3.14*9/100/8) - (100/9)) * (i - 1)  / 5000) / 4819) ^ 2) * (.25^2 / 25.82) * (((100/9)+ (3.14/(2*3.14*9/100/8)- (100/9)) * (i - 1)  / 5000)/ 25.82) ^ 4 / (1* (1 + (((100/9) + (3.14/(2*3.14*9/100/8)- (100/9)) * (i - 1)  / 5000) / 25.82) )^ (17/6)))* cos( ((100/9) + (3.14/(2*3.14*9/100/8) - (100/9)) * (i - 1)  / 5000) * (2/(2*3.14*9/100/8))*sin(.5* ((100/9) + (3.14/(2*3.14*9/100/8) - (100/9)) * (i - 1)  / 5000)* (2*3.14*9/100/8)*sin( acos(pRand(-1,1))) * sin(rand(0,2*3.14)) )* y + (rand(-3.14/2,3.14/2)))
